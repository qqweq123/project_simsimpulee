# Mellow Wave 데이터 아키텍처 및 프론트엔드 통합 표준 규격서 (Standard Architecture Guide)

**작성 날짜**: 2026-02-24
**작성자**: Mellow Wave 데이터 통합 처리 총괄 디렉터 (Data Architecture Director)

> **목적**: 본 문서는 '무인도 생존 유형 테스트(Island Test)' 리뉴얼 프로젝트를 관통하며 정립된 데이터 거버넌스, 서버리스(Serverless) 파이프라인, 그리고 프론트엔드 UI 렌더링 최적화의 **단일 진실 공급원(SSOT, Single Source of Truth)** 입니다. 향후 제작될 모든 심리테스트 모듈의 설계 지침이자 검증 기준으로 작용합니다.

---

## 1. 초기 목표 대비 최종 아키텍처 (Initial Goals vs. Final Outcomes)

### ❌ 초기 상태 (Legacy Monolithic)
*   **하드코딩된 데이터 모델**: 결과 화면의 구조(배너 리스트, 이미지 경로)가 HTML/JS 소스코드 내부에 강하게 결합되어 있어, PM 마케터가 텍스트 하나를 수정하기 위해 전체 빌드/배포 사이클을 타야만 했습니다.
*   **비효율적인 에셋 페이로드**: `.png` 기반의 무거운 통짜 이미지를 클라이언트 사이드에서 그대로 다운로드하여 LCP(최대 콘텐츠 풀 페인트) 로딩 지연이 심각했습니다.

### ✅ 최종 구현 (Serverless & Data-Driven)
*   **이미지-드리븐(Image-Driven) 모듈화**: 프론트엔드와 디자인/마케팅 데이터의 생명주기를 완벽히 분리했습니다. `target_url`, `banner_url` 등 핵심 파라미터만 JSON 스키마로 선언(`hotContentsMock`)하면, DOM 렌더링이 동적으로 반응하는 아키텍처를 도입했습니다.
*   **CDN 및 WebP 스트리밍**: 무거운 정적 자원들을 **Supabase CDN** 스토리지로 마이그레이션 하였으며, 자체 개발한 Node.js 배치 스크립트(`upload_banners.js`)를 통해 압축률이 극대화된 **WebP 포맷**으로 일괄 트랜스포밍 후 전송하도록 최적화했습니다.

---

## 2. 핵심 표준 규격서 (Core Standards & Specifications)

Mellow Wave의 기술 부채(Technical Debt)를 최소화하고 퍼포먼스를 유지하기 위한 절대적 기준입니다.

### A. 에셋 최적화 및 전달 파이프라인 (Asset Data Pipeline)
1. **데이터 포맷**: 사이트의 방문자의 *경험을 해치지 않는 선에서 가장 절감된 데이터 용량*을 목표로 진행해야 합니다. 
2. **데이터 규격**: 서비스의 배경, 썸네일, 배너 등 모든 비트맵 레이어는 예외 없이 **`WebP`** 포맷으로 렌더링되어야 합니다. (평균 용량 80% 이상 절감)
3. **저장소 거버넌스**: 에셋은 깃허브 레포지토리 로컬 환경(`public/images`)이 아닌, **Supabase CDN (`test_image` 버킷)** 에 업로드 및 분산 캐싱되어야 합니다. 그리고 저장소의 데이터 분류는 반드시 체계적이며 효율적으로, 유지, 보수, 확장성을 고려해야 합니다.
4. **심리스(Seamless) 텍스처 패턴**: 타일링 가능한 텍스처 이미지를 생성하여 CSS의 `background-repeat: repeat` 와 `mix-blend-mode: multiply`를 결합해 통짜 해상도 로딩을 방지합니다.

### B. UI/UX 렌더링 규격 (Banner & Design Validation)
1. **파노라마 프로모션 (Banner Standard Resolution)**: 모바일 피드형 배너의 원본 해상도는 **1200 x 330 (약 4:1의 와이드 파노라마 비율)** 로 엄격히 통제합니다. 
2. **하이브리드 풀-블리드 레이아웃 (V9 Hybrid Full-bleed)**: 
   * 상위 컨테이너의 패딩을 좌우로 취소하는 네거티브 마진(`-mx-8`)을 활용해 화면 모서리에 딱 맞붙는 가로 확장을 적용합니다. 
   * 단, 각 개별 개체의 모서리는 `rounded-2xl` 속성을 주어 캡슐형 독립 객체라는 시각적 단서를 제공해야 합니다.

---

## 3. 핵심 이슈 회고 및 문제 해결 (Key Retrospectives)

### 🚨 고전했던 테크니컬 바운더리 (Bottlenecks & Automation Challenges)
* **AI 생성 이미지의 캔버스 잉여 패딩 (Garbage Data)**
  * AI가 프롬프트 의도와 무관하게 임의의 회색/반투명 여백 프레임을 생성해버리는 현상이 발생했습니다.
  * 프론트엔드에서 CSS(ex: `object-cover`) 필터로 가릴 수 있으나, 이는 브라우저의 렌더링 비용을 증가시키므로 아키텍트 측면에서 불합격입니다.
  * **해결**: 데이터를 파이프라인에서 전처리(Cleansing)하기 위해 Node.js 환경의 `sharp` 모듈을 도입했습니다. AI 원본을 자동으로 읽어 불필요한 외곽을 잘라내고(trim), `attention` 알고리즘을 통해 **1200x330으로 강제 후크롭하는 자동화 스크립트(`crop_banners.js`, `format_banners.js`)**를 구축하여 쓰레기 데이터를 원천 차단했습니다.

### 🔄 수정이 가장 많았던 UI 기획 (Frequent Revisions)
* **배너 레이아웃 간격(Gap)과 타이포그래피 황금비율 탐색**
  * (V1) 제로 갭(Zero-gap) 타일 뷰 -> (V4) 여백과 라운드 추가 -> (V7) 완전한 풀-블리드 모서리 삭제 -> (V9) 하이브리드 확장 및 둥근 모서리 복원까지 총 **5차례가 넘는 컴포넌트 이터레이션**이 발생했습니다.
  * 또한 배경의 글래스모피즘 텍스처와 결과 텍스트 간의 가독성(Signal-to-Noise) 밸런스를 맞추기 위해 내부 패딩(`p-7` -> `p-5`)과 안쪽 그림자(`shadow-inner`) 테스트가 수반되었습니다.
  * **인사이트(Lesson Learned)**: 프론트엔드가 하드코딩 되어있었다면 불가능한 속도였습니다. 데이터 레이어를 `hotContentsMock`으로 분리하고 Tailwind의 유틸리티 클래스로만 통제했기에, 디렉터의 지시사항을 즉시 뷰(View)단에 렌더링하며 애자일(Agile)하게 디자인을 확정지을 수 있었습니다.

---

## 4. 로드맵 (Future Roadmaps & Implementations)

본 규격을 기초로 하여, 향후 스프린트에서 고도화해야 할 마일스톤입니다.

1. **완전 자동화된 추천 API 설계 (Recommendation Engine API)**
   * 현재 `data.js` 내부에 배열로 하드코딩된 프로모션 목업 데이터를, 유저의 MBTI/유형 결과값을 파라미터로 받아 개인화된 추천 목록을 응답(Response)하는 백엔드 서버(Supabase Edge Functions 등)로 고도화합니다.
2. **에셋 파이프라인 CI/CD 통합 (Asset CI/CD Automation)**
   * 디자인팀이 `.png` 원본 이미지를 지정된 Git 경로에 푸시(Push)할 경우, GitHub Actions를 통해 **`포맷 검증 -> 자동 크롭 -> WebP 변환 -> Supabase 로드`** 의 전과정을 무인 자동화하는 컴플라이언스 파이프라인을 구축해야 합니다.
3. **가치 창출 및 A/B 테스트 로그 병합 (Data Enablement)**
   * 배너 탭 클릭 로그 및 LCP 로드 데이터를 수집하여 애널리틱스 리포트를 생성할 수 있도록 버튼 앵커 태그 요소에 사용자 행위 트래킹(UTM, Mixpanel Event 등)을 결합합니다.


## **5. 단기 우선 목표 로드맵**

최우선으로 단기적으로 진행하여야 할 목표는 다음과 같습니다.


1. **island_test의 코드 검토**
    현재 island_test의 코드를 데이터 공학적 관점에서 면밀히 검토하여, 오류코드, 중복코드, 비효율적인 코드등을 제거하고 코드의 가독성 및 유지보수성을 높여야 합니다.
    island_test의 코드 중 보안에 위배되는 중대사항이 있는지 확인하고, 있다면 수정해야 합니다.
    island_test의 코드 중 기타 중대 이슈 등이 있는지 면밀하게 검토하여 수정해야 합니다.
    이 모든 사항의 workflow, work-pipeline 등의 구성은 **상용화와 템플릿화를 목표**로 아주 심도깊게 접근하여야 합니다.
    
2. **island_test의 고도화**. 
    질문지, 결과값에 대한 해설, 심리테스트 데이터 판별 로직등을 고도화 작업 필요.
    목표는 **상용화**와 **사용자의 공감성 및 재미, 경험 자체의 질을 높이는 것**입니다.
    다만 심리테스트가 너무 길어져 *사용자가 지루함을 느끼지 않도록* 하는 것이 중요합니다. 
    
3. **island_test의 데이터베이스화 작업 필요.**
    island_test의 질문지, 결과값, 해설등을 데이터베이스화 작업 필요합니다.
    때문에 island_test의 <head>와 <title>등을 면밀히 작업하여 데이터베이스 작업화에 용이하도록 진행 및 더불어
    웹페이지의 노출도를 올리는 작업을 진행하여야 합니다.
        메타데이터 및 SEO 최적화: 웹페이지의 노출도와 공유 효율을 높이기 위해 <head>, <title>, 그리고 Open Graph (og:tags) 속성을 면밀히 설계합니다. (예: 카카오톡 공유 시 매력적인 이미지와 제목 노출)

    또한 해쉬태그(#)를 이용하여 데이터 분류 및 검색이 용이하도록, 데이터 수집에 용이하도록 진행하여야 합니다.
        해시태그(#) 분류 체계 도입: #외향형, #리더십, #힐링 등의 해시태그를 메타데이터에 삽입하여 향후 데이터 분류, 검색, 그리고 트렌드 분석이 용이하도록 설계합니다.

    + [추가] 데이터 전문학적(Data Engineering) 요구사항 검토
    단순 저장을 넘어, 향후 빅데이터 분석 및 타겟 마케팅에 활용하기 위한 데이터 아키텍처 설계 기준입니다.

    가. 스키마 분리 설계 (Schema Separation)
        Test_Meta_DB: 테스트 자체의 정보 (문항, 선택지 가중치, 결과지 해설, 매핑된 해시태그)
        User_Result_DB: 사용자의 최종 결과 데이터 (생성된 고유 ID, 최종 도출된 타입, 공유 여부, 접속 기기, 유입 경로(UTM))
        Event_Log_DB: 행동 데이터 (각 문항별 체류 시간, 특정 문항에서의 이탈률)

    나. 텔레메트리 (Telemetry) 및 행동 추적 로직
        문항별 체류 시간 수집: 사용자가 특정 질문에서 얼마나 고민했는지 측정하여, 문항의 난이도나 모호성을 지속적으로 평가(A/B 테스트)합니다.
        전환율(Conversion Rate) 추적: '테스트 시작' -> '완료' -> '결과 공유버튼 클릭' -> '외부 링크(Call To Action) 클릭'으로 이어지는 퍼널(Funnel) 데이터를 수집하여 병목 구간을 파악합니다.

    다. 식별 불가 데이터 수집 (Anonymous Tracking)
        개인정보보호법(GDPR 등)을 준수하기 위해, 이름/연락처 등 직접적인 개인정보 없이 UUID(브라우저 고유 식별자) 기반의 익명 세션 데이터를 수집하여 통계적 유의성을 확보합니다.

3. **island_test 하단의 추천 테스트 베너 URL의 로직 구현**
    현재는 임의로 지정된 URL을 사용하고 있습니다. 하지만 이는 최종적으로 user recommendation 로직을 통해 구현되어야 합니다.
    uer recommenation 로직을 구현하기 위해, *4개의 추천 테스트의 기준을 명확히 설립하고*이를 실행시킬때에
    필요한 소스들을 분석하고, 정확하고 알맞은 로직을 구현하여야 합니다.
        콘텐츠의 DB화: 질문 텍스트, 선택지, 결과 이미지를 하드코딩하지 않고 데이터베이스에서 불러오도록(Fetch) 구조를 변경합니다. (이는 향후 템플릿화의 핵심입니다).

4. **island_test의 메인 이미지 구현**
    island_test의 배너 이미지가 없습니다.
    각 테스트들은 1200x330의 해상도를 가진 배너 이미지를 필요로 하며, index.html과 test_list.html등에 사용될
    이미지를 구현하여야 합니다. 이는 반드시 index.html과 test_list.html의 article section에 알맞은 크기로 구현되어야 합니다.
    
    
    